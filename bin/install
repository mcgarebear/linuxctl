#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

# help writes usage information to the console.
help () {
  local -r executable=${1}
  cat << EOF
${executable} [flag..]

SYNOPSIS:
  ${executable} downloads and installs artifacts such as packages,
  configuration files, etc to bootstrap the system.


FLAGS:
  --all
    Installs all package type.
  --cloud
    Installs cloud provider packages.
  --container
    Installs container and container orchestration packages.
  --developer
    Installs developer packages.
  -h, --help
    Display usage and exit.
  --misc
    Install miscellaneous packages.
EOF
}

# -------------------------------------
# Cloud Providers
# -------------------------------------

install_aws () {
  local -r tmp="$(mktemp --directory)"
  curl -o "${tmp}/awscliv2.zip" \
    "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"
  unzip "${tmp}/awscliv2.zip" -d "${tmp}"
  sudo "${tmp}/aws/install" \
    --install-dir '/usr/local/aws-cli' \
    --bin-dir '/usr/local/bin' \
    --update
  rm -rf "${tmp}"
  return 0
}

install_azure () {
  curl -sL 'https://aka.ms/InstallAzureCLIDeb' \
    | sudo bash
  return 0
}

install_gcloud () {
  sudo snap install google-cloud-cli --classic
  return 0
}

# -------------------------------------
# Container
# -------------------------------------

install_docker () {
  sudo apt-get install -y ca-certificates curl
  sudo install -m 0755 -d /etc/apt/keyrings
  sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
  sudo chmod a+r /etc/apt/keyrings/docker.asc

  # Add the repository to Apt sources:
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
    $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
    sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  sudo apt-get update

  # Install packages
  sudo apt-get install -y \
    docker-ce \
    docker-ce-cli \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin
  return 0
}

install_helm () {
  local -r tmp="$(mktemp --directory)"
  curl --silent \
    --show-error \
    --location \
    --fail \
    -o "${tmp}/helm" \
    "https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3"
  chmod 700 \
    "${tmp}/helm"
  exec "${tmp}/helm"
  rm -rf "${tmp}"
}

install_kubectl () {
  local -r tmp="$(mktemp --directory)"
  local -r latest="$(curl -L -s https://dl.k8s.io/release/stable.txt)"
  curl -L \
    -o "${tmp}/kubectl" \
    "https://dl.k8s.io/release/${latest}/bin/linux/amd64/kubectl"
  sudo install \
    -o root \
    -g root \
    -m 0755 \
    "${tmp}/kubectl" \
    /usr/local/bin/kubectl
  rm -rf "${tmp}"

  return 0
}

# -------------------------------------
# Developer
# -------------------------------------

install_vim () {
  local -r __file_path=$(realpath $0)
  local -r __file_name=$(basename "${__file_path}")
  local -r __file_dir=$(dirname "${__file_path}")

  local -r config_dir=$(realpath "${__file_dir}/../config")
  [[ -f ${HOME}/.vimrc ]] \
    || cp --archive "${config_dir}/vim/.vimrc" "${HOME}"

  sudo apt-get install -y neovim vim

  # Create the vim package directory if it does not already exist
  local -r vim_pack_dir="${HOME}/.vim/pack"
  [[ -d "${vim_pack_dir}" ]] \
    || mkdir --parents "${vim_pack_dir}"

  # Map with keys of strings representing the GITHUB SHORT NAME. Each
  # key has a corresponding TAG string as value. Plugins are organized
  # by TAGS, each will correspond to a subfolder in the package dir.
  declare -A repos=(
    ["fatih/vim-go"]="plugins"
    ["tc50cal/vim-terminal"]="plugins"
    ["preservim/nerdtree"]="plugins"
    ["jiangmiao/auto-pairs"]="plugins"
    ["preservim/nerdcommenter"]="plugins"
    ["jvirtanen/vim-hcl"]="syntax"
  )

  # For each entry in the map, use the GITHUB SHORT NAME to build the clone
  # URL. Use TAG and GITHUB SHORT NAME to construct plugin destination path.
  for repo in ${!repos[@]}; do
    githubURL="git@github.com:${repo}.git"
    repoName=$( \
      sed "s/.*\///g" \
        <<< "${repo}" \
    )
    tag=${repos[$repo]}
    repoDestination="${vim_pack_dir}/${tag}/start/${repoName}"

    [[ -d "${repoDestination}" ]] \
      || git clone "${githubURL}" "${repoDestination}"
  done

  return 0
}

install_c () {
  sudo apt-get install -y build-essential
  return 0
}

install_golang () {
  local -r __architecture=$(dpkg --print-architecture)

  # Root workspace for all Golang projects.
  export GOPATH="${HOME}/go"
  # Where to place `go install` binaries.
  export GOBIN="${GOPATH}/bin"
  # Location of Golang install.
  export GOROOT="/usr/local/go"
  # Add `go install` binaries as well as the go install itself.
  export PATH="/usr/local/go/bin:${PATH}"
  export PATH="${GOBIN}:${PATH}"

  # Setup root workspace
  #
  # bin: executables
  # pkg: compiled packages
  # src: source code
  local -r go_dirs=(
    "${GOPATH}"
    "${GOBIN}"
    "${GOPATH}/bin"
    "${GOPATH}/pkg"
    "${GOPATH}/src"
  )
  for dir in "${go_dirs[@]}"; do
    [[ -d "${dir}" ]] \
      || mkdir -p "${dir}"
  done

  # Retrieve the version of go to install from their site
  local -r go_version="1.25.3"
  local -r go_arch="${__architecture}"
  local -r go_targz="go${go_version}.linux-${go_arch}.tar.gz"
  local -r tmp="$(mktemp --directory)"
  local -r go_install_out="${tmp}/${go_targz}"
  curl --location \
  --output "${go_install_out}" \
  "https://go.dev/dl/${go_targz}"

  # Remove the current install and unpack the install
  # into GOROOT
  [[ -d "${GOROOT}" ]] && sudo rm -rf "${GOROOT}"
  sudo tar -C /usr/local -xzf "${go_install_out}"
  rm -rf "${tmp}"

  return 0
}

install_python () {
  sudo apt-get install -y python3 python3-pip

  return 0
}

install_rust () {
  curl --proto '=https' \
    --tlsv1.2 \
    -sSf https://sh.rustup.rs \
  | sh

  return 0
}

# -------------------------------------

# main is the entry point of the script. It returns zero upon successful
# execution. If an error was encountered during execution, it returns non-zero.
main () {
  local -r __file_path=$(realpath $0)
  local -r __file_name=$(basename "${__file_path}")

  local all=0
  local cloud=0
  local container=0
  local developer=0
  local misc=0

  while test $# -gt 0; do
    case "$1" in
      -h | --help)
        help "${__file_name}"
        return 0
        ;;
      --all)
        all=1
        shift 1
        ;;
      --cloud)
        cloud=1
        shift 1
        ;;
      --container)
        container=1
        shift 1
        ;;
      --developer)
        developer=1
        shift 1
        ;;
      --misc)
        misc=1
        shift 1
        ;;
      *)
        echo "Error: Unrecognized input ${1}"
        echo ""
        help "${__file_name}"
        return 1
        ;;
    esac
  done

  if (( ${all} == 1 || ${cloud} == 1 )); then
    install_aws
    install_azure
    install_gcloud
  fi

  if (( ${all} == 1 || ${container} == 1 )); then
    install_docker
    install_helm
    install_kubectl
  fi

  if (( ${all} == 1 || ${developer} == 1 )); then
    sudo apt-get install -y \
      curl \
      git \
      jq \
      ripgrep \
      tmux \
      unzip \
      wget \
      yq

    [[ -f "${HOME}/.gitconfig" ]] \
      || cp --archive "${config_dir}/git/.gitconfig" "${home}"
    [[ -f "${HOME}/.gitignore" ]] \
      || cp --archive "${config_dir}/git/.gitignore" "${home}"

    install_c
    install_golang
    install_python
    install_rust
    install_vim
  fi

  if (( ${all} == 1 || ${misc} == 1 )); then
    sudo apt-get install -y \
      bc \
      htop \
      neofetch \
      scrot \
      top \
      tree
  fi

  return 0
}

main $@
